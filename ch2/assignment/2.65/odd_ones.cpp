#include <iostream>
using namespace std;

/*
http://stackoverflow.com/a/9133406
偷瞄了下别人的代码，一看到就懂了
采用分治思想，每次对半进行异或操作
异或操作你可以认为就是模2运算，只要知道是模2运算，也就相当于加法模2操作，你就能理解了
毕竟等于2相当于有偶数个1了，去掉即可

如果不清楚为什么是16、8、4、2、1，不会影响到其他位吗？
先把高16位拉到低16位，与之低16位进行异或操作，此时低16位保存了数据，高16位可以不管了，即使后续位移操作会影响到那些位数，但是我们数据保存在低位中，是不受影响的
然后再把低16位中的高8位拉到低8位....
[16][     16      ]
    [8][    8     ]
       [4][   4   ]
          [2][  2 ]
             [1][1]
*/
// 奇数个1返回1，否则返回0
int odd_ones(unsigned x) {
    x ^= x >> 16;
    x ^= x >> 8;
    x ^= x >> 4;
    x ^= x >> 2;
    x ^= x >> 1;
    return x & 1;
}

int main()
{
    assert(odd_ones(0x10101011));
    assert(!odd_ones(0x01010101));
    return 0;
}